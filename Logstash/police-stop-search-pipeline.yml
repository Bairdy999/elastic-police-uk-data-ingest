input {
  file {
# Point to the required stop and search CSV file(s)
    path => "/opt/data/UK/Police/crime-data/<year_range>/*-<force_name>-stop-and-search.csv"
    start_position => "beginning"
  }
}

filter {
  csv {
    separator => ","
    skip_header => true
# Map the CSV fields to the relevant index fields
    columns => [
      "[stop][type]",
      "[stop][date]",
      "[policing_operation][part_of]",
      "[policing_operation][name]",
      "[location][lat]",
      "[location][lon]",
      "[person][gender]",
      "[person][age_range]",
      "[person][self_defined_ethnicity]",
      "[person][officer_defined_ethnicity]",
      "[stop][legislation]",
      "[stop][object_of_search]",
      "[stop][outcome]",
      "[stop][outcome_linked_to_search]",
      "[stop][removal_of_clothing]"
    ]
# Ignore empty values in any of the columns. The default value is false if not specified and we want to continue if there are empty values
    skip_empty_columns => true
  }
# The CSV filter maps boolean values as strings so convert to boolean where required:
  if [policing_operation][part_of] {
    mutate {
      convert => {
        "[policing_operation][part_of]" => "boolean"
      }
    }
  } else {
# And add a default value of false if it doesn't exist
    mutate {
      add_field => { "[policing_operation][part_of]" => false}
    }
  }

# Convert the lat/lon co-ordinates to float so they can be correctly ingested as a geopoint value:
  if [location][lat] {
    mutate {
      convert => {
        "[location][lat]" => "float"
      }
    }
  }

  if [location][lon] {
    mutate {
      convert => {
        "[location][lon]" => "float"
      }
    }
  }
# The CSV filter maps boolean values as strings so convert to boolean where required:
  mutate {
    convert => {
      "[stop][outcome_linked_to_search]" => "boolean"
      "[stop][removal_of_clothing]" => "boolean"
    }
  }

  mutate {
    copy => { "[log][file][path]" => "logfile" }
  }
# "/opt/data/UK/Police/crime-data/2024-01/2024-01-derbyshire-stop-and-search.csv"

  mutate {
    gsub => [
# Remove superfluous parts of the filepath to get the reporting period and Force name as it isn't in the actual data:
      "logfile", "/opt/data/UK/Police/crime-data/", "",
      "logfile", "-stop-and-search.csv", ""
    ]
  }

# And parse the logfile name to determine the reporting period and reporting Force as it only exists in the filename and not in the data:
  dissect {
    mapping => {
      "logfile" => "%{[reporting][period]}/%{[reporting][year]}-%{[reporting][month]}-%{[force][reported_by]}"
    }
  }

# Convert any hyphens to spaces for readability
  mutate {
    gsub => [
      "[force][reported_by]", "-", " "
    ]
  }

# And convert each Force name to camel case with the correct Force naming terminology:
  if [force][reported_by] == "btp" {
    mutate {
      replace => { "[force][reported_by]" => "British Transport Police" }
    }
  }

  if [force][reported_by] == "devon and cornwall" {
    mutate {
      replace => { "[force][reported_by]" => "Devon & Cornwall Police" }
    }
  }

  if [force][reported_by] == "dyfed powys" {
    mutate {
      replace => { "[force][reported_by]" => "Dyfed-Powys Police" }
    }
  }

  if [force][reported_by] == "metropolitan" {
    mutate {
      replace => { "[force][reported_by]" => "Metropolitan Police Service" }
    }
  }

  if [force][reported_by] == "northern ireland" {
    mutate {
      replace => { "[force][reported_by]" => "Police Service of Northern Ireland" }
    }
  }

  if [force][reported_by] in ["avon and somerset", "cambridgeshire", "cheshire", "cumbria", "derbyshire", "durham", "gloucestershire", "hampshire", "hertfordshire", "lancashire", "norfolk", "suffolk"] {
    mutate {
      replace => { "[force][reported_by]" => "%{[force][reported_by]} Constabulary" }
    }
  }

  if [force][reported_by] in ["bedfordshire", "city of london", "cleveland", "dorset", "greater manchester", "gwent", "humberside", "kent", "leicestershire", "lincolnshire", "merseyside", "north wales", "north yorkshire", "northamptonshire", "northumbria", "nottinghamshire", "sourh wales", "south yorkshire", "staffordshire", "surrey", "sussex", "thames valley", "warwickshire", "west mercia", "west midlands", "west yorkshire"] {
    mutate {
      replace => { "[force][reported_by]" => "%{[force][reported_by]} Police" }
    }
  }

  ruby {
    code => 'event.set("[force][reported_by]", event.get("[force][reported_by]").split.map(&:capitalize).join(" "))'
  }

# Finally remove any superfluous fields that aren't required:
  mutate {
    remove_field => [ "tmp1", "logfile", "event" ]
  }
}

# Output to the relevant Elasticsearch cluster:
output {
  elasticsearch {
    ecs_compatibility => disabled
    hosts => "https://<cluster_url>:<cluster_http_port>/<extra_uri>"
    user => "elastic"
    password => "**************"
    ssl_verification_mode => "none"
    index => "police-data-stop-search"
    data_stream => "false"
  }
}